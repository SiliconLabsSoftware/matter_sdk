#include "GroupcastLogic.h"
#include <app/util/endpoint-config-api.h>
#include <credentials/GroupDataProvider.h>

namespace chip {
namespace app {
namespace Clusters {

using GroupDataProvider = Credentials::GroupDataProvider;
using GroupInfo         = Credentials::GroupDataProvider::GroupInfo;
using GroupEndpoint     = Credentials::GroupDataProvider::GroupEndpoint;
using GroupInfoIterator = Credentials::GroupDataProvider::GroupInfoIterator;
using EndpointIterator  = Credentials::GroupDataProvider::EndpointIterator;

CHIP_ERROR GroupcastLogic::ReadMembership(const chip::Access::SubjectDescriptor * subject, EndpointId endpoint,
                                          AttributeValueEncoder & aEncoder)
{
    VerifyOrReturnError(nullptr != subject, CHIP_ERROR_INVALID_ARGUMENT);
    FabricIndex fabric_index = subject->fabricIndex;

    GroupDataProvider * groups = &Provider();

    CHIP_ERROR err = aEncoder.EncodeList([fabric_index, groups](const auto & encoder) -> CHIP_ERROR {
        EndpointList endpoints;
        CHIP_ERROR status              = CHIP_NO_ERROR;
        GroupInfoIterator * group_iter = groups->IterateGroupInfo(fabric_index);
        VerifyOrReturnError(nullptr != group_iter, CHIP_ERROR_NO_MEMORY);

        GroupInfo info;
        while (group_iter->Next(info) && (CHIP_NO_ERROR == status))
        {
            // Group Key
            KeysetId keyset_id = 0;
            ReturnErrorOnFailure(groups->GetGroupKey(fabric_index, info.group_id, keyset_id));

            // Endpoints
            EndpointIterator * end_iter = groups->IterateEndpoints(fabric_index, info.group_id);
            if (nullptr == end_iter)
            {
                status = CHIP_ERROR_NO_MEMORY;
                break;
            }

            // Return endpoints in kMaxMembershipEndpoints chunks or less
            size_t group_total = end_iter->Count();
            size_t group_count = 0;
            size_t split_count = 0;
            GroupEndpoint mapping;
            while (end_iter->Next(mapping) && (CHIP_NO_ERROR == status))
            {
                group_count++;
                endpoints.entries[split_count++] = mapping.endpoint_id;
                if ((group_count == group_total) || (split_count == kMaxMembershipEndpoints))
                {
                    Groupcast::Structs::MembershipStruct::Type group;
                    group.fabricIndex     = fabric_index;
                    group.groupID         = info.group_id;
                    group.keySetID        = keyset_id;
                    group.hasAuxiliaryACL = MakeOptional(info.flags & chip::to_underlying(GroupInfo::Flags::kHasAuxiliaryACL));
                    group.mcastAddrPolicy = (info.flags & chip::to_underlying(GroupInfo::Flags::kMcastAddrPolicy)
                                                 ? Groupcast::MulticastAddrPolicyEnum::kPerGroup
                                                 : Groupcast::MulticastAddrPolicyEnum::kIanaAddr);
                    group.endpoints       = MakeOptional(DataModel::List<const chip::EndpointId>(endpoints.entries, split_count));
                    status                = encoder.Encode(group);
                    split_count           = 0;
                }
            }
            end_iter->Release();
        }
        group_iter->Release();

        return status;
    });

    return err;
}

CHIP_ERROR GroupcastLogic::ReadMaxMembershipCount(EndpointId endpoint, AttributeValueEncoder & aEncoder)
{
    GroupDataProvider & groups = Provider();
    return aEncoder.Encode(groups.getMaxMembershipCount());
}

Status GroupcastLogic::JoinGroup(FabricIndex fabric_index, const Groupcast::Commands::JoinGroup::DecodableType & data)
{
    GroupDataProvider & groups = Provider();
    CHIP_ERROR err             = CHIP_NO_ERROR;

    // Check groupID
    VerifyOrReturnError(data.groupID != kUndefinedGroupId, Status::ConstraintError);

    // Check useAuxiliaryACL
    if (data.useAuxiliaryACL.HasValue())
    {
        // AuxiliaryACL can only be present if LN feature is supported
        VerifyOrReturnError(mFeatures.Has(Groupcast::Feature::kListener), Status::ConstraintError);
    }

    // Check endpoints
    size_t endpoint_count = 0;
    err                   = data.endpoints.ComputeSize(&endpoint_count);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
    if (mFeatures.Has(Groupcast::Feature::kListener) && !mFeatures.Has(Groupcast::Feature::kSender))
    {
        // Listener only, endpoints cannot be empty
        VerifyOrReturnError(endpoint_count > 0 && endpoint_count <= kMaxCommandEndpoints, Status::ConstraintError);
    }
    else if (!mFeatures.Has(Groupcast::Feature::kListener) && mFeatures.Has(Groupcast::Feature::kSender))
    {
        // Sender only, endpoints must be empty
        VerifyOrReturnError(0 == endpoint_count, Status::ConstraintError);
    }
    // Verify endpoint values
    {
        auto iter = data.endpoints.begin();
        while (iter.Next())
        {
            EndpointId ep = iter.GetValue();
            VerifyOrReturnError((ep > 0) && (kInvalidEndpointId != ep), Status::ConstraintError);
            // VerifyOrReturnError(nullptr != emberAfFindEndpointType(ep), Status::ConstraintError);
        }
    }

    // Check fabric membership entries limit
    GroupDataProvider::GroupInfo info;
    err = groups.GetGroupInfo(fabric_index, data.groupID, info);
    VerifyOrReturnError(CHIP_ERROR_NOT_FOUND == err || CHIP_NO_ERROR == err, Status::Failure);
    // If the group is new, the fabric entries will increase
    uint16_t new_count              = (CHIP_ERROR_NOT_FOUND == err) ? info.count + 1 : info.count;
    uint16_t max_fabric_memberships = static_cast<uint16_t>(groups.getMaxMembershipCount() / 2);
    VerifyOrReturnError(new_count <= max_fabric_memberships, Status::ResourceExhausted);

    // Key handling
    if (data.key.HasValue())
    {
        // Create a new keyset
        Status stat = SetKeySet(fabric_index, data.keySetID, data.key.Value());
        VerifyOrReturnError(Status::Success == stat, stat);
    }
    else
    {
        // The keyset must exist
        GroupDataProvider::KeySet ks;
        err = groups.GetKeySet(fabric_index, data.keySetID, ks);
        VerifyOrReturnError(CHIP_NO_ERROR == err, Status::NotFound);
    }
    // Assign keyset to group
    err = groups.SetGroupKey(fabric_index, data.groupID, data.keySetID);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);

    // Add/update entry in the group table
    info.group_id = data.groupID;
    info.flags    = 0;
    if (data.useAuxiliaryACL.HasValue() && data.useAuxiliaryACL.Value())
    {
        info.flags |= chip::to_underlying(GroupInfo::Flags::kHasAuxiliaryACL);
    }

    if (data.mcastAddrPolicy.HasValue() && (Groupcast::MulticastAddrPolicyEnum::kPerGroup == data.mcastAddrPolicy.Value()))
    {
        info.flags |= chip::to_underlying(GroupInfo::Flags::kMcastAddrPolicy);
    }

    err = groups.SetGroupInfo(fabric_index, info);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);

    if (data.replaceEndpoints.HasValue() && data.replaceEndpoints.Value())
    {
        // Replace endpoints
        err = groups.RemoveEndpoints(fabric_index, data.groupID);
        VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
    }

    // Add Endpoints
    {
        size_t group_count = 0;
        auto iter          = data.endpoints.begin();
        while (iter.Next() && (group_count++ < kMaxCommandEndpoints))
        {
            err = groups.AddEndpoint(fabric_index, data.groupID, iter.GetValue());
            VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
        }
    }

    return Status::Success;
}

Status GroupcastLogic::LeaveGroup(FabricIndex fabric_index, const Groupcast::Commands::LeaveGroup::DecodableType & data,
                                  EndpointList & endpoints)
{
    GroupDataProvider & groups = Provider();
    Status err                 = Status::Success;

    endpoints.count = 0;
    if (kUndefinedGroupId == data.groupID)
    {
        // Apply changes to all groups
        GroupInfoIterator * iter = groups.IterateGroupInfo(fabric_index);
        VerifyOrReturnError(nullptr != iter, Status::ResourceExhausted);

        GroupInfo info;
        while (iter->Next(info) && (Status::Success == err))
        {
            err = RemoveGroup(fabric_index, info.group_id, data, endpoints);
        }
        iter->Release();
    }
    else
    {
        // Modify specific group
        err = RemoveGroup(fabric_index, data.groupID, data, endpoints);
    }

    return err;
}

Status GroupcastLogic::UpdateGroupKey(FabricIndex fabric_index, const Groupcast::Commands::UpdateGroupKey::DecodableType & data)
{
    GroupDataProvider & groups = Provider();

    // Key handling
    if (data.key.HasValue())
    {
        // Create a new keyset
        Status stat = SetKeySet(fabric_index, data.keySetID, data.key.Value());
        VerifyOrReturnError(Status::Success == stat, stat);
    }
    // Assign keyset to group
    CHIP_ERROR err = groups.SetGroupKey(fabric_index, data.groupID, data.keySetID);
    return CHIP_NO_ERROR == err ? Status::Success : Status::Failure;
}

Status GroupcastLogic::ConfigureAuxiliaryACL(FabricIndex fabric_index,
                                             const Groupcast::Commands::ConfigureAuxiliaryACL::DecodableType & data)
{
    GroupDataProvider & groups = Provider();
    CHIP_ERROR err             = CHIP_NO_ERROR;

    // Get group info
    GroupDataProvider::GroupInfo info;
    err = groups.GetGroupInfo(fabric_index, data.groupID, info);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::NotFound);

    // Update group info
    if (data.useAuxiliaryACL)
    {
        info.flags |= chip::to_underlying(GroupInfo::Flags::kHasAuxiliaryACL);
    }
    else
    {
        info.flags &= ~chip::to_underlying(GroupInfo::Flags::kHasAuxiliaryACL);
    }
    err = groups.SetGroupInfo(fabric_index, info);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);

    return Status::Success;
}

Status GroupcastLogic::SetKeySet(FabricIndex fabric_index, KeysetId keyset_id, const chip::ByteSpan & key)
{
    GroupDataProvider & groups = Provider();
    GroupDataProvider::KeySet ks;

    CHIP_ERROR err = groups.GetKeySet(fabric_index, keyset_id, ks);
    if (CHIP_ERROR_NOT_FOUND == err)
    {
        // New key
        const FabricInfo * fabric = Fabrics().FindFabricWithIndex(fabric_index);
        VerifyOrReturnValue(nullptr != fabric, Status::NotFound);

        ks.keyset_id     = keyset_id;
        ks.policy        = GroupDataProvider::SecurityPolicy::kTrustFirst;
        ks.num_keys_used = 1;

        GroupDataProvider::EpochKey & epoch = ks.epoch_keys[0];
        VerifyOrReturnValue(key.size() == GroupDataProvider::EpochKey::kLengthBytes, Status::ConstraintError);
        memcpy(epoch.key, key.data(), GroupDataProvider::EpochKey::kLengthBytes);

        {
            // Get compressed fabric
            uint8_t compressed_fabric_id_buffer[sizeof(uint64_t)];
            MutableByteSpan compressed_fabric_id(compressed_fabric_id_buffer);
            err = fabric->GetCompressedFabricIdBytes(compressed_fabric_id);
            VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
            // Set keys
            err = groups.SetKeySet(fabric_index, compressed_fabric_id, ks);
            VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
        }
    }
    else if (CHIP_NO_ERROR == err)
    {
        // Cannot set an existing key
        return Status::AlreadyExists;
    }
    return Status::Success;
}

Status GroupcastLogic::RemoveGroup(FabricIndex fabric_index, GroupId group_id,
                                   const Groupcast::Commands::LeaveGroup::DecodableType & data, EndpointList & endpoints)
{
    GroupDataProvider & groups = Provider();
    Status stat                = Status::Success;

    if (data.endpoints.HasValue())
    {
        // Remove endpoints
        auto iter = data.endpoints.Value().begin();
        while (iter.Next() && (endpoints.count < kMaxCommandEndpoints))
        {
            auto endpoint_id = iter.GetValue();
            if (groups.HasEndpoint(fabric_index, group_id, endpoint_id))
            {
                stat = RemoveGroupEndpoint(fabric_index, group_id, endpoint_id, endpoints);
                VerifyOrReturnError(Status::Success == stat, stat);
            }
        }
    }
    else
    {
        // Remove whole group (with all endpoints)
        EndpointIterator * iter = groups.IterateEndpoints(fabric_index, data.groupID);
        VerifyOrReturnError(nullptr != iter, Status::ResourceExhausted);
        GroupEndpoint mapping;
        while (iter->Next(mapping) && (endpoints.count < kMaxMembershipEndpoints))
        {
            stat = RemoveGroupEndpoint(fabric_index, group_id, mapping.endpoint_id, endpoints);
            VerifyOrReturnError(Status::Success == stat, stat);
        }
        iter->Release();
        CHIP_ERROR err = groups.RemoveGroupInfo(fabric_index, data.groupID);
        VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);
    }

    return Status::Success;
}

Status GroupcastLogic::RemoveGroupEndpoint(FabricIndex fabric_index, GroupId group_id, EndpointId endpoint_id,
                                           EndpointList & endpoints)
{
    GroupDataProvider & groups = Provider();

    CHIP_ERROR err = groups.RemoveEndpoint(fabric_index, group_id, endpoint_id);
    VerifyOrReturnError(CHIP_NO_ERROR == err, Status::Failure);

    bool found = false;
    for (size_t i = 0; !found && i < endpoints.count; ++i)
    {
        found = (endpoints.entries[i] == endpoint_id);
    }
    if (!found)
    {
        endpoints.entries[endpoints.count++] = endpoint_id;
    }
    return Status::Success;
}

} // namespace Clusters
} // namespace app
} // namespace chip
